
/// **Itinerary Models - Extended with Transport, Stays & Budget**
/// 
/// Extended JSON structure for complete trip planning:
/// {
///   "title": "Kyoto 5-Day Solo Trip",
///   "startDate": "2025-04-10", 
///   "endDate": "2025-04-15",
///   "days": [...],
///   "transport": {...},
///   "stays": [...],
///   "budget": {...}
/// }
library;

import 'booking_models.dart';

/// Main itinerary model with transport, stays, and budget
class ItineraryModel {
  /// Unique identifier for the itinerary
  String id;
  
  /// Trip title generated by AI
  String title;
  
  /// Start date in ISO format (YYYY-MM-DD)
  String startDate;
  
  /// End date in ISO format (YYYY-MM-DD)  
  String endDate;
  
  /// List of daily plans
  List<DayPlanModel> days;
  
  /// Transport plan (flights, trains, local transport)
  TransportPlan? transport;
  
  /// Accommodation stays
  StaysPlan? stays;
  
  /// Budget breakdown and tracking
  BudgetPlan? budget;
  
  /// User's original prompt that generated this itinerary
  String? originalPrompt;
  
  /// Timestamp when itinerary was created
  DateTime? createdAt;
  
  /// Timestamp when itinerary was last modified
  DateTime? updatedAt;

  ItineraryModel({
    required this.id,
    required this.title,
    required this.startDate,
    required this.endDate,
    required this.days,
    this.transport,
    this.stays,
    this.budget,
    this.originalPrompt,
    this.createdAt,
    this.updatedAt,
  });

  /// Manual JSON serialization - includes transport, stays, budget
  Map<String, dynamic> toJson() {
    return {
      'title': title,
      'startDate': startDate,
      'endDate': endDate,
      'days': days.map((day) => day.toJson()).toList(),
      if (transport != null) 'transport': transport!.toJson(),
      if (stays != null) 'stays': stays!.toJson(),
      if (budget != null) 'budget': budget!.toJson(),
    };
  }

  /// Manual JSON deserialization - handles extended fields
  factory ItineraryModel.fromJson(Map<String, dynamic> json) {
    // Parse days from JSON
    final daysData = json['days'] as List<dynamic>;
    final daysList = daysData.map((dayJson) => 
        DayPlanModel.fromJson(dayJson as Map<String, dynamic>)
    ).toList();
    
    return ItineraryModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: json['title'] as String,
      startDate: json['startDate'] as String,
      endDate: json['endDate'] as String,
      days: daysList,
      transport: json['transport'] != null 
          ? TransportPlan.fromJson(json['transport'] as Map<String, dynamic>)
          : null,
      stays: json['stays'] != null 
          ? StaysPlan.fromJson(json['stays'] as Map<String, dynamic>)
          : null,
      budget: json['budget'] != null 
          ? BudgetPlan.fromJson(json['budget'] as Map<String, dynamic>)
          : null,
      createdAt: DateTime.now(),
    );
  }
  
  /// Calculate trip duration in days
  int get durationDays => days.length;
  
  /// Check if transport is set
  bool get hasTransport => transport != null && transport!.allSegments.isNotEmpty;
  
  /// Check if stays are set
  bool get hasStays => stays != null && stays!.stays.isNotEmpty;
  
  /// Check if budget is set
  bool get hasBudget => budget != null;
  
  /// Get total estimated cost
  double get totalEstimatedCost {
    double total = 0;
    if (transport != null) total += transport!.totalCost;
    if (stays != null) total += stays!.totalCost;
    if (budget != null) {
      total += budget!.estimated.food;
      total += budget!.estimated.activities;
      total += budget!.estimated.shopping;
      total += budget!.estimated.misc;
    }
    return total;
  }
  
  /// Create a copy with updated fields
  ItineraryModel copyWith({
    String? id,
    String? title,
    String? startDate,
    String? endDate,
    List<DayPlanModel>? days,
    TransportPlan? transport,
    StaysPlan? stays,
    BudgetPlan? budget,
    String? originalPrompt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return ItineraryModel(
      id: id ?? this.id,
      title: title ?? this.title,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      days: days ?? this.days,
      transport: transport ?? this.transport,
      stays: stays ?? this.stays,
      budget: budget ?? this.budget,
      originalPrompt: originalPrompt ?? this.originalPrompt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

/// Simple day plan model
class DayPlanModel {
  /// Date in ISO format (YYYY-MM-DD)
  String date;
  
  /// Brief summary of the day's theme
  String summary;
  
  /// List of activities/items for this day
  List<ActivityItemModel> items;

  DayPlanModel({
    required this.date,
    required this.summary,
    required this.items,
  });

  /// Manual serialization
  Map<String, dynamic> toJson() {
    return {
      'date': date,
      'summary': summary,
      'items': items.map((item) => item.toJson()).toList(),
    };
  }

  factory DayPlanModel.fromJson(Map<String, dynamic> json) {
    final itemsData = json['items'] as List<dynamic>;
    final itemsList = itemsData.map((itemJson) => 
        ActivityItemModel.fromJson(itemJson as Map<String, dynamic>)
    ).toList();
    
    return DayPlanModel(
      date: json['date'] as String,
      summary: json['summary'] as String,
      items: itemsList,
    );
  }
}

/// Activity item model
class ActivityItemModel {
  /// Time in HH:MM format (24-hour)
  String time;
  
  /// Activity description
  String activity;
  
  /// Location in "lat,lng" format for maps integration
  String location;

  ActivityItemModel({
    required this.time,
    required this.activity,
    required this.location,
  });

  /// Manual serialization
  Map<String, dynamic> toJson() {
    return {
      'time': time,
      'activity': activity,
      'location': location,
    };
  }

  /// Manual deserialization
  factory ActivityItemModel.fromJson(Map<String, dynamic> json) {
    return ActivityItemModel(
      time: json['time'] as String,
      activity: json['activity'] as String,
      location: json['location'] as String,
    );
  }
  
  /// Parse latitude from location string
  double? get latitude {
    try {
      final parts = location.split(',');
      return double.parse(parts[0]);
    } catch (e) {
      return null;
    }
  }
  
  /// Parse longitude from location string  
  double? get longitude {
    try {
      final parts = location.split(',');
      return double.parse(parts[1]);
    } catch (e) {
      return null;
    }
  }
  
  /// Get formatted time for display (12-hour format)
  String get formattedTime {
    try {
      final parts = time.split(':');
      final hour = int.parse(parts[0]);
      final minute = parts[1];
      
      if (hour == 0) return '12:$minute AM';
      if (hour < 12) return '$hour:$minute AM';
      if (hour == 12) return '12:$minute PM';
      return '${hour - 12}:$minute PM';
    } catch (e) {
      return time;
    }
  }
}

/// Enhanced Chat message model with optional itinerary
class ChatMessageModel {
  String id;
  String sessionId;
  String content; // Text message content (can be follow-up questions, descriptions, etc.)
  String role; // 'user' or 'assistant'
  DateTime timestamp;
  
  /// Optional itinerary data embedded in the message
  ItineraryModel? itinerary;
  
  /// Token usage for this message (cost tracking)
  int? tokenCount;
  
  /// Message type for better categorization
  MessageType type;

  ChatMessageModel({
    required this.id,
    required this.sessionId,
    required this.content,
    required this.role,
    required this.timestamp,
    required this.type,
    this.itinerary,
    this.tokenCount,
  });

  /// Create user message
  factory ChatMessageModel.user({
    required String sessionId,
    required String content,
  }) {
    return ChatMessageModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      sessionId: sessionId,
      content: content,
      role: 'user',
      timestamp: DateTime.now(),
      type: MessageType.userText,
    );
  }
  
  /// Create AI text message (follow-up questions, descriptions, etc.)
  factory ChatMessageModel.aiText({
    required String sessionId,
    required String content,
    int? tokenCount,
  }) {
    return ChatMessageModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      sessionId: sessionId,
      content: content,
      role: 'assistant',
      timestamp: DateTime.now(),
      type: MessageType.aiText,
      tokenCount: tokenCount,
    );
  }
  
  /// Create AI message with itinerary
  factory ChatMessageModel.aiWithItinerary({
    required String sessionId,
    required String content,
    required ItineraryModel itinerary,
    int? tokenCount,
  }) {
    return ChatMessageModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      sessionId: sessionId,
      content: content,
      role: 'assistant',
      timestamp: DateTime.now(),
      type: MessageType.aiWithItinerary,
      itinerary: itinerary,
      tokenCount: tokenCount,
    );
  }

  /// Create AI error message
  factory ChatMessageModel.aiError({
    required String sessionId,
    required String content,
  }) {
    return ChatMessageModel(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      sessionId: sessionId,
      content: content,
      role: 'assistant',
      timestamp: DateTime.now(),
      type: MessageType.aiError,
    );
  }

  /// Check if message has itinerary
  bool get hasItinerary => itinerary != null;
  
  /// Check if message is from user
  bool get isUser => role == 'user';
  
  /// Check if message is from AI
  bool get isAI => role == 'assistant';

  /// Check if message is an error
  bool get isError => type == MessageType.aiError;

  /// Create a deep copy of this message
  ChatMessageModel copyWith({
    String? id,
    String? sessionId,
    String? content,
    String? role,
    DateTime? timestamp,
    MessageType? type,
    ItineraryModel? itinerary,
    int? tokenCount,
  }) {
    return ChatMessageModel(
      id: id ?? this.id,
      sessionId: sessionId ?? this.sessionId,
      content: content ?? this.content,
      role: role ?? this.role,
      timestamp: timestamp ?? this.timestamp,
      type: type ?? this.type,
      itinerary: itinerary ?? (this.itinerary != null ? _deepCopyItinerary(this.itinerary!) : null),
      tokenCount: tokenCount ?? this.tokenCount,
    );
  }

  /// Create a deep copy of an itinerary
  ItineraryModel _deepCopyItinerary(ItineraryModel original) {
    return ItineraryModel.fromJson(original.toJson());
  }

  /// Simple JSON conversion
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'sessionId': sessionId,
      'content': content,
      'role': role,
      'timestamp': timestamp.toIso8601String(),
      'type': type.toString(),
      'itinerary': itinerary?.toJson(),
      'tokenCount': tokenCount,
    };
  }

  factory ChatMessageModel.fromJson(Map<String, dynamic> json) {
    return ChatMessageModel(
      id: json['id'] as String,
      sessionId: json['sessionId'] as String,
      content: json['content'] as String,
      role: json['role'] as String,
      timestamp: DateTime.parse(json['timestamp'] as String),
      type: MessageType.values.firstWhere(
        (e) => e.toString() == json['type'],
        orElse: () => MessageType.userText,
      ),
      itinerary: json['itinerary'] != null 
          ? ItineraryModel.fromJson(json['itinerary']) 
          : null,
      tokenCount: json['tokenCount'] as int?,
    );
  }
}

/// Message types for better categorization
enum MessageType {
  userText,           // User's text message
  aiText,             // AI's text response (follow-up questions, descriptions)
  aiWithItinerary,    // AI's response containing both text and itinerary
  aiError,            // AI's error response
}
